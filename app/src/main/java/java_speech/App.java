/*
 * This source file was generated by the Gradle 'init' task
 */
package java_speech;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import org.apache.commons.math3.complex.Complex;

import com.opencsv.CSVReader;
import com.opencsv.exceptions.CsvValidationException;

import ai.onnxruntime.OnnxTensor;
import ai.onnxruntime.OrtEnvironment;
import ai.onnxruntime.OrtException;
import ai.onnxruntime.OrtSession;

public class App {
    private static double[] MXR;
    private static double[] MYR;
    private static double[] MZR;

    private static final String FILE_NAME_STRING = "pro_10940.csv";
    private static final int SAMPLING_FREQUENCY = 1000;
    private static final int TIME_WINDOW = 6; // in seconds
    private static final int HOP_LENGTH = 512; // in number of samples
    private static final int FRAME_LENGTH = 2048; // in number of samples

    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) throws CsvValidationException, OrtException {
        // Print the current working directory
        System.out.println("Current working directory: " + System.getProperty("user.dir"));
        System.out.println(new App().getGreeting());
        readData(FILE_NAME_STRING);

        // Use the filter function to filter the MZR data
        double[] filteredMZR = highPassButterworthFilter2ndOrder75Hz(MZR);

        System.out.print("The size of the array is: " + filteredMZR.length);

        // Get the number of windows
        int numWindows = (int) Math.floor((double) filteredMZR.length / (SAMPLING_FREQUENCY * TIME_WINDOW));

        System.out.println("Number of windows:" + numWindows);

        // Create an array to store combined RMS values and spectral features in order
        double[][] combinedFeatures = new double[numWindows][5];

        // Iterate through the windows
        for (int i = 0; i < numWindows; i++) {
            // Get the start and end indices of the current window
            int startIndex = i * SAMPLING_FREQUENCY * TIME_WINDOW;
            int endIndex = Math.min(startIndex + SAMPLING_FREQUENCY * TIME_WINDOW, filteredMZR.length);

            // Create a new array for the current window
            double[] windowData = new double[endIndex - startIndex];
            System.arraycopy(filteredMZR, startIndex, windowData, 0, endIndex - startIndex);

            // Calculate RMS for the current window
            double rmsValue = calculateMeanRMS(windowData, SAMPLING_FREQUENCY, FRAME_LENGTH, HOP_LENGTH);

            // Perform FFT on the window data
            Complex[] rfftOutput = rfft(windowData);

            // Calculate spectral features
            double[] spectralFeatures = calculateKurtosisSkewnessVarianceMeanFromRFFT(rfftOutput);

            // Calculate spectral features
            // Spectral Skewness
            // Spectral Variance
            // Spectral Kurtosis
            // RMS
            // Mean // Store features in the order skewness, variance, kurtosis, rms, mean
            combinedFeatures[i][0] = spectralFeatures[1]; // skewness
            combinedFeatures[i][1] = spectralFeatures[2]; // variance
            combinedFeatures[i][2] = spectralFeatures[0]; // kurtosis
            combinedFeatures[i][3] = rmsValue; // rms
            combinedFeatures[i][4] = spectralFeatures[3]; // mean
        }

        // Print the combined features
        for (int i = 0; i < numWindows; i++) {
            System.out.println("Window " + (i + 1) + ": " + java.util.Arrays.toString(combinedFeatures[i]));
        }

        // Load the ONNX model
        String modelPath = "init_model_xgb.onnx"; // Update with the actual path
        try (OrtEnvironment env = OrtEnvironment.getEnvironment();
                OrtSession session = env.createSession(modelPath, new OrtSession.SessionOptions())) {

            // Prepare input data (example: using combinedFeatures)
            float[][] inputData = new float[combinedFeatures.length][combinedFeatures[0].length];
            for (int i = 0; i < combinedFeatures.length; i++) {
                for (int j = 0; j < combinedFeatures[i].length; j++) {
                    inputData[i][j] = (float) combinedFeatures[i][j];
                }
            }

            // Create ONNX input tensor
            OnnxTensor inputTensor = OnnxTensor.createTensor(env, inputData);

            // Prepare input map
            Map<String, OnnxTensor> inputs = new HashMap<>();
            inputs.put("input", inputTensor); // Replace "input_name" with the actual input name of your model

            // Run inference
            try (OrtSession.Result results = session.run(inputs)) {
                // Get the output
                Object rawOutput = results.get(0).getValue();
            
                switch (rawOutput) {
                    case long[][] output -> {
                        System.out.println("Model output (long[][]): ");
                        for (long[] row : output) {
                            System.out.println(java.util.Arrays.toString(row));
                        }
                    }
                    case float[][] output -> {
                        System.out.println("Model output (float[][]): ");
                        for (float[] row : output) {
                            System.out.println(java.util.Arrays.toString(row));
                        }
                    }
                    case long[] output -> {
                        System.out.println("Model output (long[]): ");
                        System.out.println(java.util.Arrays.toString(output));
                    }
                    default -> System.out.println("Unexpected output type: " + rawOutput.getClass().getName());
                }
            }
        }
    }

    public static double calculateMeanRMS(double[] audioSignal, int sampleRate, int frameLength, int hopLength) {
        int numFrames = (int) Math.ceil((double) audioSignal.length / hopLength);
        double[] rmsValues = new double[numFrames];

        for (int i = 0; i < numFrames; i++) {
            int start = i * hopLength;
            int end = Math.min(start + frameLength, audioSignal.length);
            double sumSquares = 0;

            for (int j = start; j < end; j++) {
                sumSquares += audioSignal[j] * audioSignal[j];
            }

            double frameRms = Math.sqrt(sumSquares / (end - start));
            rmsValues[i] = frameRms;
        }

        double sumRms = 0;
        for (double rms : rmsValues) {
            sumRms += rms;
        }

        return sumRms / numFrames;
    }

    private static Complex[] rfft(double[] data) {
        int n = data.length;
        Complex[] fft = new Complex[n / 2 + 1]; // RFFT returns n/2 + 1 frequency components

        // Perform the FFT using the Cooley-Tukey algorithm
        for (int k = 0; k <= n / 2; k++) {
            double real = 0;
            double imag = 0;
            for (int t = 0; t < n; t++) {
                double angle = -2 * Math.PI * k * t / n;
                real += data[t] * Math.cos(angle);
                imag += data[t] * Math.sin(angle);
            }
            fft[k] = new Complex(real, imag);
        }

        return fft;
    }

    private static double[] calculateKurtosisSkewnessVarianceMeanFromRFFT(Complex[] rfftOutput) {
        // Calculate the magnitude spectrum
        double[] magnitudes = new double[rfftOutput.length];
        for (int i = 0; i < rfftOutput.length; i++) {
            magnitudes[i] = rfftOutput[i].abs(); // Magnitude = sqrt(real^2 + imag^2)
        }

        // Calculate the mean of the magnitudes
        double sum = 0;
        for (double magnitude : magnitudes) {
            sum += magnitude;
        }
        double mean = sum / magnitudes.length;

        // Calculate the variance, third moment, and fourth moment
        double sumSquaredDiff = 0;
        double sumThirdDiff = 0;
        double sumFourthDiff = 0;
        for (double magnitude : magnitudes) {
            double diff = magnitude - mean;
            sumSquaredDiff += diff * diff;
            sumThirdDiff += diff * diff * diff;
            sumFourthDiff += diff * diff * diff * diff;
        }
        double variance = sumSquaredDiff / magnitudes.length;

        // Calculate skewness
        double skewness = (sumThirdDiff / magnitudes.length) / Math.pow(variance, 1.5);

        // Calculate kurtosis
        double kurtosis = (sumFourthDiff / magnitudes.length) / (variance * variance) - 3;

        return new double[] { kurtosis, skewness, variance, mean };
    }

    public static void readData(String fileName) throws CsvValidationException {
        try {
            File file = new File(fileName);
            // Read the header line
            try (CSVReader reader = new CSVReader(new FileReader(file))) {
                // Initialize arrays to store data
                MXR = new double[0];
                MYR = new double[0];
                MZR = new double[0];

                // Read data into arrays
                String[] data;
                int count = 0;
                int NUM_OF_SECONDS = 30; // Number of seconds to read
                int MAX_DATA = NUM_OF_SECONDS * 6000; // seconds * 6000 samples per second

                // Skip the header line
                reader.readNext();

                // Read the rest of the data line by line
                while ((data = reader.readNext()) != null && count++ < MAX_DATA) {
                    MXR = addElement(MXR, Double.parseDouble(data[4]));
                    MYR = addElement(MYR, Double.parseDouble(data[5]));
                    MZR = addElement(MZR, Double.parseDouble(data[6]));
                }
            }

            // Print the data arrays
            // System.out.println("MXR: " + java.util.Arrays.toString(MXR));
            // System.out.println("MYR: " + java.util.Arrays.toString(MYR));
            // System.out.println("MZR: " + java.util.Arrays.toString(MZR));
        } catch (FileNotFoundException e) {
            System.out.println("File not found.");
        } catch (IOException e) {
            System.out.println("Error reading file.");
        }
    }

    private static double[] highPassButterworthFilter2ndOrder75Hz(double[] data) {
        double fc = 75.0; // cutoff frequency
        double Q = Math.sqrt(2) / 2; // Q factor for Butterworth filter

        double w0 = 2 * Math.PI * fc / SAMPLING_FREQUENCY;
        double alpha = Math.sin(w0) / (2 * Q);

        double b0 = (1 + Math.cos(w0)) / 2;
        double b1 = -(1 + Math.cos(w0));
        double b2 = (1 + Math.cos(w0)) / 2;
        double a0 = 1 + alpha;
        double a1 = -2 * Math.cos(w0);
        double a2 = 1 - alpha;

        double[] filteredData = new double[data.length];

        for (int i = 0; i < data.length; i++) {
            switch (i) {
                case 0:
                    filteredData[i] = b0 * data[i] / a0;
                    break;
                case 1:
                    filteredData[i] = (b0 * data[i] + b1 * data[i - 1] - a1 * filteredData[i - 1]) / a0;
                    break;
                default:
                    filteredData[i] = (b0 * data[i] + b1 * data[i - 1] + b2 * data[i - 2] - a1 * filteredData[i - 1]
                            - a2 * filteredData[i - 2]) / a0;
                    break;
            }
        }

        return filteredData;
    }

    private static double[] addElement(double[] originalArray, double newElement) {
        double[] newArray = new double[originalArray.length + 1];
        System.arraycopy(originalArray, 0, newArray, 0, originalArray.length);
        newArray[newArray.length - 1] = newElement;
        return newArray;
    }
}
