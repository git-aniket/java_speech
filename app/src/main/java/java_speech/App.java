/*
 * This source file was generated by the Gradle 'init' task
 */
package java_speech;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

import org.apache.commons.math3.complex.Complex;

import com.opencsv.CSVReader;
import com.opencsv.exceptions.CsvValidationException;

public class App {
    private static double[] MXR;
    private static double[] MYR;
    private static double[] MZR;

    private static final String  FILE_NAME_STRING = "pro_10940.csv";

    private static double calculateSpectralVariance(double[] windowData) {
        if (windowData == null || windowData.length == 0) {
            throw new IllegalArgumentException("Input array is empty or null");
        }
        double sum = 0;
        for (double p : windowData) {
            sum += p;
        }
        double mean = sum / windowData.length;
        double sumSqr = 0;
        for (double p : windowData) {
            sumSqr += Math.pow(p - mean, 2);
        }
        double variance = sumSqr / windowData.length;
        return variance;
    }

    private static double calculateSpectralKurtosis(double[] windowData) {
        if (windowData == null || windowData.length == 0) {
            throw new IllegalArgumentException("Input array is empty or null");
        }
        double sum = 0;
        for (double p : windowData) {
            sum += p;
        }
        double mean = sum / windowData.length;
        double sumSqr = 0;
        double sumQuad = 0;
        for (double p : windowData) {
            double diff = p - mean;
            sumSqr += diff * diff;
            sumQuad += diff * diff * diff * diff;
        }
        double variance = sumSqr / windowData.length;
        double kurtosis = (sumQuad / windowData.length) / (variance * variance) - 3;
        return kurtosis;
    }

    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) throws CsvValidationException {
        //Print the current working directory
        System.out.println("Current working directory: " + System.getProperty("user.dir"));
        System.out.println(new App().getGreeting());
        readData(FILE_NAME_STRING);

        // Use the filter function to filter the MZR data
        double[] filteredMZR = highPassButterworthFilter2ndOrder75Hz(MZR);
        System.out.println("Filtered MZR: " + java.util.Arrays.toString(filteredMZR));

        // // Calculate the spectral features every 6000 samples
        // int sampleRate = 1000;
        // int noOfSeconds = 6; 
        // int stepSize = sampleRate*noOfSeconds; // 6000 samples
        // int numWindows = (int) Math.floor((double) filteredMZR.length / stepSize);
        // double[][] spectralFeatures = new double[numWindows][3]; // 3 features: skewness, variance, kurtosis

        // for (int i = 0; i < numWindows; i++) {
        //     int startIndex = i * stepSize;
        //     int endIndex = Math.min((i + 1) * stepSize, filteredMZR.length);
        //     double[] windowData = java.util.Arrays.copyOfRange(filteredMZR, startIndex, endIndex);
        //     spectralFeatures[i][0] = calculateSpectralSkewness(windowData);
        //     spectralFeatures[i][1] = calculateSpectralVariance(windowData);
        //     spectralFeatures[i][2] = calculateSpectralKurtosis(windowData);
        // }

        // Calculate spectral features
        // Spectral Skewness
        // Spectral Variance
        // Spectral Kurtosis
        // RMS
        // Mean
    }

    private static double calculateSpectralSkewness(double[] windowData) {
        // Calculate the power spectral density (PSD) using Welch's method
        double[] psd = welchPSD(windowData, 1000, 1000, 0.5);

        // Calculate the spectral skewness
        double sum = 0;
        double sumSqr = 0;
        double sumCube = 0;
        for (double p : psd) {
            sum += p;
            sumSqr += p * p;
            sumCube += p * p * p;
        }
        double mean = sum / psd.length;
        double variance = (sumSqr / psd.length) - (mean * mean);
        double skewness = (sumCube / psd.length) - (3 * mean * variance) - (mean * mean * mean);
        skewness /= Math.pow(variance, 1.5);
        return skewness;
    }

    // Calculate the power spectral density (PSD) using Welch's method
    private static double[] welchPSD(double[] data, int nperseg, int noverlap, double detrend) {
        int nfft = 2 * nperseg;
        int n = data.length;
        double[] psd = new double[nfft];

        for (int i = 0; i < (n - nperseg); i += (nperseg - noverlap)) {
            double[] segment = java.util.Arrays.copyOfRange(data, i, i + nperseg);
            double[] window = new double[nperseg];
            for (int j = 0; j < nperseg; j++) {
                window[j] = 0.5 * (1 - Math.cos(2 * Math.PI * j / (nperseg - 1)));
            }
            double[] scaledSegment = new double[nperseg];
            for (int j = 0; j < nperseg; j++) {
                scaledSegment[j] = segment[j] * window[j];
            }
            double[] fft = fft(scaledSegment);
            for (int j = 0; j < nfft / 2; j++) {
                psd[j] += Math.pow(fft[j], 2);
            }
        }

        for (int i = 0; i < nfft / 2; i++) {
            psd[i] /= (n * nfft);
        }
        return psd;
    }

    // Compute the Fast Fourier Transform (FFT) of a sequence
    private static double[] fft(double[] data) {
        int n = data.length;
        double[] fft = new double[n];
        double[] w = new double[n / 2];

        for (int i = 0; i < n / 2; i++) {
            Complex w_i = new Complex(Math.cos(2 * Math.PI * i / n), Math.sin(2 * Math.PI * i / n));
            w[i] = w_i.getReal();
        }

        for (int i = 0; i < n; i++) {
            double sum = 0;
            for (int j = 0; j < n / 2; j++) {
                sum += data[i + j] * w[j];
            }
            fft[i] = sum;
        }

        return fft;
    }

    public static void readData(String fileName) throws CsvValidationException{
        try {
            File file = new File(fileName);
            // Read the header line
            try (CSVReader reader = new CSVReader(new FileReader(file))) {
                // Initialize arrays to store data
                MXR = new double[0];
                MYR = new double[0];
                MZR = new double[0];

                // Read data into arrays
                String[] data;
                int count = 0;
                int MAX_DATA = 10*6000; // 10 seconds * 6000 samples per second

                // Skip the header line
                reader.readNext();

                // Read the rest of the data line by line
                while ((data = reader.readNext()) != null && count++ < MAX_DATA) {
                    MXR = addElement(MXR, Double.parseDouble(data[4]));
                    MYR = addElement(MYR, Double.parseDouble(data[5]));
                    MZR = addElement(MZR, Double.parseDouble(data[6]));
                }
            }

            // Print the data arrays
            System.out.println("MXR: " + java.util.Arrays.toString(MXR));
            System.out.println("MYR: " + java.util.Arrays.toString(MYR));
            System.out.println("MZR: " + java.util.Arrays.toString(MZR));
        } catch (FileNotFoundException e) {
            System.out.println("File not found.");
        } catch (IOException e) {
            System.out.println("Error reading file.");
        }
    }

    private static double[] highPassButterworthFilter2ndOrder75Hz(double[] data) {
        double fs = 1000.0; // sampling frequency
        double fc = 75.0; // cutoff frequency
        double Q = Math.sqrt(2) / 2; // Q factor for Butterworth filter
    
        double w0 = 2 * Math.PI * fc / fs;
        double alpha = Math.sin(w0) / (2 * Q);
    
        double b0 = (1 + Math.cos(w0)) / 2;
        double b1 = -(1 + Math.cos(w0));
        double b2 = (1 + Math.cos(w0)) / 2;
        double a0 = 1 + alpha;
        double a1 = -2 * Math.cos(w0);
        double a2 = 1 - alpha;
    
        double[] filteredData = new double[data.length];
    
        for (int i = 0; i < data.length; i++) {
            switch (i) {
                case 0:
                    filteredData[i] = b0 * data[i] / a0;
                    break;
                case 1:
                    filteredData[i] = (b0 * data[i] + b1 * data[i - 1] - a1 * filteredData[i - 1]) / a0;
                    break;
                default:
                    filteredData[i] = (b0 * data[i] + b1 * data[i - 1] + b2 * data[i - 2] - a1 * filteredData[i - 1] - a2 * filteredData[i - 2]) / a0;
                    break;
            }
        }
    
        return filteredData;
    }

    private static double[] addElement(double[] originalArray, double newElement) {
        double[] newArray = new double[originalArray.length + 1];
        System.arraycopy(originalArray, 0, newArray, 0, originalArray.length);
        newArray[newArray.length - 1] = newElement;
        return newArray;
    }
}

